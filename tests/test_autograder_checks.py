import os
import sys
from unittest.mock import patch, MagicMock
import pytest

project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
if project_root not in sys.path:
    sys.path.insert(0, project_root)
app_dir = os.path.join(project_root, 'app')
if app_dir not in sys.path:
    sys.path.insert(0, app_dir)

from app import main as main_mod


def test_main_exits_on_invalid_github_token(monkeypatch):
    # Ensure that when a processing command is provided and GITHUB_TOKEN is missing/invalid, main exits with code 1
    monkeypatch.setenv('GITHUB_TOKEN', '')
    # Ensure argv triggers processing (not install/test)
    monkeypatch.setattr(sys, 'argv', ['run', 'somefile.txt'])
    with patch('app.main.requests.get', side_effect=Exception('network')):
        with pytest.raises(SystemExit) as exc:
            main_mod.main()
        assert exc.value.code == 1


def test_main_exits_on_invalid_log_file_path(monkeypatch):
    # Provide an invalid LOG_FILE (parent directory does not exist)
    monkeypatch.setenv('LOG_FILE', '/path/that/does/not/exist/log.txt')
    monkeypatch.setenv('GITHUB_TOKEN', 'fake')
    # Mock requests.get to return 200 so token validation passes if reached
    with patch('app.main.requests.get', return_value=MagicMock(status_code=200)):
        monkeypatch.setattr(sys, 'argv', ['run', 'test'])
        # Running 'test' should skip token validation but still validate log path during preflight
        with pytest.raises(SystemExit) as exc:
            main_mod.main()
        assert exc.value.code == 1
